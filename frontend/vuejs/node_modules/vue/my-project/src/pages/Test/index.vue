<template>
  <div>
    <h1>自定义v-model的基础使用</h1>
    <div>{{name}}</div>
    <CustomVModel v-model="name"></CustomVModel>
    <h1>v-model 实例</h1>
    <div>{{count}}</div>
    <CustomVModelEG v-model="count"></CustomVModelEG>
    <h1>slot基本使用</h1>
    <SlotDome :url="webkit.url">
      {{webkit.title}}
    </SlotDome>
    <h1>作用域插槽</h1>
    <ScopedSlotDome :url="webkit.url">
      <template v-slot="slotProps">
        {{slotProps.slotData.title}}
      </template>
    </ScopedSlotDome>
    <h1>具名插槽</h1>
    <MoreSlotDome>
      <template v-slot:header>
        header
      </template>
      <p>内容</p>
      <template v-slot:footer>
        footer
      </template>
    </MoreSlotDome>
    <div v-for="(val, key) in list" :key="key">
      <component :is="val.type"></component>
    </div>
    <h1>异步加载组件</h1>
    <Test1 v-if="showDemo" />
    <button @click="showDemo = true">切换</button>
    <h1>缓存组件 - keep-alive</h1>
    <button @click="change('A')">A</button>
    <button @click="change('B')">B</button>
    <button @click="change('C')">C</button>
    <!-- 如果不使用keep-alive，导致每次切换都会销毁上一个组件 -->
    <!-- <KeepAliveA v-if="state === 'A'" />
    <KeepAliveB v-if="state === 'B'" />
    <KeepAliveC v-if="state === 'C'" /> -->
    <!-- 解决方案 -->
    <keep-alive>
      <KeepAliveA v-if="state === 'A'" />
      <KeepAliveB v-if="state === 'B'" />
      <KeepAliveC v-if="state === 'C'" />
    </keep-alive>

    <h2>mixin</h2>
    <button @click="changeCity">切换城市</button>
    {{city}}

  </div>
</template>

<script>
// 同步加载组件
// 自定义v-model
import CustomVModel from '@/components/CustomVModel'
import CustomVModelEG from '@/components/CustomVModelEG'

// 插槽
// 基本使用：父组件内容要在子组件里正常显示
import SlotDome from '@/components/SlotDome'
// 作用域插槽
import ScopedSlotDome from '@/components/ScopedSlotDome'
// 具名插槽
import MoreSlotDome from '@/components/MoreSlotDome'
// $nextTick
// - vue是异步渲染
// - data改变之后，dom不是立刻去渲染
// - $nextTick 会在dom渲染之后被触发，以获取最新的dom节点

// 动态组件
// - :is="componentName"
// - 需要根据数据，动态渲染不同的场景，即组件类型不确定
import TextDome from '@/components/Text'

// 异步组件
// - import()函数
// - 按需加载，异步加载大组件

// keep-alive
// - 缓存组件
// - 频繁切换，不需要重新渲染
// - vue常见性能优化
import KeepAliveA from '@/components/KeepAliveA'
import KeepAliveB from '@/components/KeepAliveB'
import KeepAliveC from '@/components/KeepAliveC'

// mixin
// - 多个组件有相同逻辑，抽离出来
// - mixin并不是完美解决方案，会有一些问题
//   1. 变量来源不明确，不利于阅读。可读性差
//   2. 多个mixin可能造成命名冲突
//   3. mixin可能与组件出现多对多的关系，复杂度较高
// - vue3 提出Composition API 旨在解决这个问题

import MyMixin from '@/components/mixin'
export default {
  name: 'Test',
  mixins: [MyMixin],
  data () {
    return {
      name: 'test',
      count: 0,
      webkit: {
        url: 'www.baidu.com',
        title: '百度'
      },
      list: {
        1: {
          type: 'TextDome'
        },
        2: {
          type: 'ImageDome'
        },
        3: {
          type: 'TextDome'
        },
        4: {
          type: 'VideoDome'
        }
      },
      showDemo: false,
      state: 'A'
    }
  },
  components: {
    CustomVModel,
    CustomVModelEG,
    SlotDome,
    ScopedSlotDome,
    MoreSlotDome,
    TextDome,
    Test1: () => import('@/components/Test'),
    KeepAliveA,
    KeepAliveB,
    KeepAliveC
  },
  mounted () {
    console.log('test mounted')
  },
  methods: {
    change (val) {
      this.state = val
    }
  }
}
</script>
